{"mappings":"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","sources":["node_modules/shortid/lib/index.js","node_modules/shortid/lib/alphabet.js","node_modules/shortid/lib/random/random-from-seed.js","node_modules/shortid/lib/build.js","node_modules/shortid/lib/generate.js","node_modules/shortid/lib/random/random-byte-browser.js","node_modules/nanoid/index.browser.js","node_modules/shortid/lib/is-valid.js","node_modules/shortid/lib/util/cluster-worker-id-browser.js","node_modules/shortid/index.js","src/js/03-to-go-list.js"],"sourcesContent":["'use strict';\n\nvar alphabet = require('./alphabet');\nvar build = require('./build');\nvar isValid = require('./is-valid');\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId = require('./util/cluster-worker-id') || 0;\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet.characters(newCharacters);\n    }\n\n    return alphabet.shuffled();\n}\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n  return build(clusterWorkerId);\n}\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.isValid = isValid;\n","'use strict';\n\nvar randomFromSeed = require('./random/random-from-seed');\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nfunction get () {\n  return alphabet || ORIGINAL;\n}\n\nmodule.exports = {\n    get: get,\n    characters: characters,\n    seed: setSeed,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n","'use strict';\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nmodule.exports = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n","'use strict';\n\nvar generate = require('./generate');\nvar alphabet = require('./alphabet');\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1567752802062;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 7;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction build(clusterWorkerId) {\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + generate(version);\n    str = str + generate(clusterWorkerId);\n    if (counter > 0) {\n        str = str + generate(counter);\n    }\n    str = str + generate(seconds);\n    return str;\n}\n\nmodule.exports = build;\n","'use strict';\n\nvar alphabet = require('./alphabet');\nvar random = require('./random/random-byte');\nvar customRandom = require('nanoid').customRandom;\n\nfunction generate(number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + customRandom(alphabet.get(), 1, random)();\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nmodule.exports = generate;\n","'use strict';\n\nvar crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto\n\nvar randomByte;\n\nif (!crypto || !crypto.getRandomValues) {\n    randomByte = function(size) {\n        var bytes = [];\n        for (var i = 0; i < size; i++) {\n            bytes.push(Math.floor(Math.random() * 256));\n        }\n        return bytes;\n    };\n} else {\n    randomByte = function(size) {\n        return crypto.getRandomValues(new Uint8Array(size));\n    };\n}\n\nmodule.exports = randomByte;\n","// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nimport { urlAlphabet } from './url-alphabet/index.js'\n\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\n\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let j = step | 0\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    byte &= 63\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","'use strict';\nvar alphabet = require('./alphabet');\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var nonAlphabetic = new RegExp('[^' +\n      alphabet.get().replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&') +\n    ']');\n    return !nonAlphabetic.test(id);\n}\n\nmodule.exports = isShortId;\n","'use strict';\n\nmodule.exports = 0;\n","'use strict';\nmodule.exports = require('./lib/index');\n","import shortid from \"shortid\";\nconst formEl = document.querySelector(\".form\");\nconst listEl = document.querySelector(\".list\");\nconst textareaEl = document.querySelector(\"#textarea\");\nconst KEY = \"toDoKey\";\nlet toDoItem = JSON.parse(localStorage.getItem(KEY)) || [];\n\n\nformEl.addEventListener(\"submit\", onAddToDoItem);\nlistEl.addEventListener(\"click\", onDeleteItem);\nonLoadMarkup();\n\n\nfunction onAddToDoItem(e) {\n    e.preventDefault();\n    \n    if (textareaEl.value.trim() === \"\") {\n        return alert(\"Enter your to do\");\n    }\n    const element = {\n        id: shortid(),\n        value: textareaEl.value.trim(),\n    };\n    \n    toDoItem.push(element);\n    localStorage.setItem(KEY, JSON.stringify(toDoItem));\n   \n    listEl.innerHTML = creartMarkup(toDoItem);\n    \n    formEl.reset();\n};\n\n\nfunction creartMarkup(data) {\n    return data.map(({id, value}) => {\n          return  `\n           <li class=\"list__item\">\n           <p>${value}</p> \n           <button id=${id}>Delete</button>\n           </li>\n    `}).join(\"\");\n};\n\n\nfunction onLoadMarkup() {\n    const storageToDo = JSON.parse(localStorage.getItem(KEY));\n    \n    if (storageToDo) {\n      toDoItem = storageToDo;\n      listEl.innerHTML = creartMarkup(storageToDo)\n    }\n};\n\n\nfunction onDeleteItem(e) {\n\n    if (e.target.tagName !== \"BUTTON\") {\n        return;\n    }\n    const id = e.target.id;\n    toDoItem = toDoItem.filter((el) => el.id !== id);\n    localStorage.setItem(KEY, JSON.stringify(toDoItem));\n\n    listEl.innerHTML = creartMarkup(toDoItem);\n};\n\n"],"names":["$93d10f2f37393922$var$clusterWorkerId","parcelRequire","$93d10f2f37393922$var$generate","$diNzO","module","exports","generate","seed","seedValue","$g4BPj","worker","workerId","characters","newCharacters","undefined","shuffled","isValid","$61E5S","$bb3a5c9e6d2a0ebf$var$alphabet","$bb3a5c9e6d2a0ebf$var$previousSeed","$bb3a5c9e6d2a0ebf$var$shuffled","$bb3a5c9e6d2a0ebf$var$ORIGINAL","$bb3a5c9e6d2a0ebf$var$reset","$bb3a5c9e6d2a0ebf$var$setCharacters","_alphabet_","length","Error","unique","split","filter","item","ind","arr","lastIndexOf","join","$bb3a5c9e6d2a0ebf$var$getShuffled","characterIndex","sourceArray","targetArray","r","$hhrj1","nextValue","Math","floor","push","splice","$bb3a5c9e6d2a0ebf$var$shuffle","get","lookup","index","$c949349598bf8531$var$seed","_seed_","$9af369ad58a92862$var$counter","$9af369ad58a92862$var$previousSeconds","clusterWorkerId","str","seconds","Date","now","$UoLZd","customRandom","number","done","loopCounter","$0a98727953de3b2f$require$customRandom","$aTGu4","pow","$7eeffedb0d78b4c2$var$randomByte","$7eeffedb0d78b4c2$var$crypto","window","crypto","msCrypto","getRandomValues","size","Uint8Array","bytes","i","random","$8069ef7e6126e429$export$a5cee9e955a615e5","alphabet","defaultSize","getRandom","mask","log","LN2","step","arguments","id","j","RegExp","replace","test","$8f08804a7ffc63d8$exports","storageToDo","$a21b3979492e7e22$var$formEl","document","querySelector","$a21b3979492e7e22$var$listEl","$a21b3979492e7e22$var$textareaEl","$a21b3979492e7e22$var$KEY","$a21b3979492e7e22$var$toDoItem","JSON","parse","localStorage","getItem","$a21b3979492e7e22$var$creartMarkup","data","map","param","value","concat","addEventListener","e","preventDefault","trim","alert","element","$parcel$interopDefault","setItem","stringify","innerHTML","reset","target","tagName","el"],"version":3,"file":"04-to-go-list.e7e4d271.js.map"}